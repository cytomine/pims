stages:
  - prepare
  - test
  - build
  - publish
  - clean

# variable to register in project:
# - DOCKERHUB_URL: url of dockerhub (e.g. docker.io)
# - DOCKERHUB_USER: cytomine username on dockerhub
# - DOCKERHUB_PASSWORD: cytomine password on dockerhub
# - SCRIPTS_REPO_ACCESS_TOKEN_NAME: access token name for docker-entrypoint-scripts repo
# - SCRIPTS_REPO_ACCESS_TOKEN_VALUE: access token value for docker-entrypoint-scripts repo
# - SCRIPTS_REPO_URL: git url (no scheme/protocol) of the docker-entrypoint-scripts repo
# - PYPI_USERNAME: pypi username for package upload
# - PYPI_PASSWORD: pypi password for package upload

default:
  tags:
    - docker

variables:
  PYTHON_VERSION: "3.8"
  DOCKERHUB_PIMS_REPO: cytomine/pims
  DOCKER_IMAGE_NAME_FOR_TESTS: $CI_PIPELINE_ID-test:latest
  DOCKER_IMAGE_NAME_TMP_BUILD: $CI_PIPELINE_ID:latest

workflow:
  rules:
    # - if: $CI_COMMIT_REF_PROTECTED != "true"
    #   when: never
    # only publish artifacts (docker image and python package) if tag is a PEP440 compatible version (see long regex) 
    # open-source if tag is not post- nor pre-release  
    - if: $CI_COMMIT_TAG != null && $CI_COMMIT_TAG =~ /^v?(?:[0-9]+!)?[0-9]+(?:\.[0-9]+)*$/
      variables:
        PUBLISH_ARTIFACTS: "true"
        IS_OPEN_SOURCE_RELEASE_CANDIDATE: "true"
    - if: $CI_COMMIT_TAG != null && $CI_COMMIT_TAG =~ /^v?((?:[0-9]+!)?[0-9]+(?:\.[0-9]+)*(?:[-_\.]?(?:a|b|c|rc|alpha|beta|pre|preview)[-_\.]?(?:[0-9]+)?)?(?:-[0-9]+|[-_\.]?(?:post|rev|r)[-_\.]?(?:[0-9]+)?)?(?:[-_\.]?dev[-_\.]?(?:[0-9]+)?)?)(?:\+[a-z0-9]+(?:[-_\.][a-z0-9]+)*)?$/
      variables:
        PUBLISH_ARTIFACTS: "true"
        IS_OPEN_SOURCE_RELEASE_CANDIDATE: "false"
    - if: $CI_COMMIT_TAG == null || $CI_COMMIT_TAG !~ /^v?((?:[0-9]+!)?[0-9]+(?:\.[0-9]+)*(?:[-_\.]?(?:a|b|c|rc|alpha|beta|pre|preview)[-_\.]?(?:[0-9]+)?)?(?:-[0-9]+|[-_\.]?(?:post|rev|r)[-_\.]?(?:[0-9]+)?)?(?:[-_\.]?dev[-_\.]?(?:[0-9]+)?)?)(?:\+[a-z0-9]+(?:[-_\.][a-z0-9]+)*)?$/
      variables:
        PUBLISH_ARTIFACTS: "false"
        IS_OPEN_SOURCE_RELEASE_CANDIDATE: "false"

build-python-package:
  stage: build
  image: python:$PYTHON_VERSION-slim-bullseye
  rules:
    - if: $PUBLISH_ARTIFACTS == "true"
  script:
    - sed -i -- "s/__version__ = \"0.0.0\"/__version__ = \"$CI_COMMIT_TAG\"/g" pims/__version__.py
    - python setup.py sdist
    # Canonical version is automatically generated by setuptools matching PEP440
    - DIST_FILENAME=$(ls dist/pims-*.tar.gz)
    - |
      if [ ! -f "$DIST_FILENAME" ]; then
        echo "could not build the package, $DIST_FILENAME seems to be missing"
        exit -1
      fi
    - VERSION=$(python -c 'import re; import sys; m = re.match(r"^dist/pims-(.+)\.tar\.gz$", sys.argv[1].strip()); print(m.group(1))' $DIST_FILENAME) 
    - echo "CANONICAL_VERSION_NUMBER=$VERSION" > .env
  artifacts:
    paths:
      - dist/pims-*.tar.gz
    reports:
      # to export canonical version number
      dotenv: .env

# build docker image for test
build-docker-image-for-tests:
  stage: prepare
  image: docker:latest
  script:
    - export SCRIPTS_REPO_FULL_URL=https://$SCRIPTS_REPO_ACCESS_TOKEN_NAME:$SCRIPTS_REPO_ACCESS_TOKEN_VALUE@$SCRIPTS_REPO_URL
    - docker build --build-arg SCRIPTS_REPO_TAG=latest --build-arg PLUGIN_CSV="scripts/plugin-list.csv" --secret id=scripts_repo_url,env=SCRIPTS_REPO_FULL_URL -t $DOCKER_IMAGE_NAME_FOR_TESTS -f docker/backend.dockerfile --target test-runner .

run-pytest:
  stage: test
  image: 
    name: $DOCKER_IMAGE_NAME_FOR_TESTS
    entrypoint: [""]
    pull_policy: never
  needs:
    - job: build-docker-image-for-tests
      artifacts: false
  script:
    - pytest ./tests --junit-xml=ci/test-reports/pytest_unit.xml
  artifacts:
    reports:
      junit: ci/test-reports/pytest_unit.xml

# need to set the pims version number right in the container files
# mostly cached
build-docker-image-for-publish:
  stage: build
  image: docker:latest
  rules:
    - if: $PUBLISH_ARTIFACTS == "true"
  needs:
    - job: run-pytest
      artifacts: false
    - job: build-python-package
      artifacts: true  # need canonical version number
  script:
    - sed -i -- "s/__version__ = \"0.0.0\"/__version__ = \"$CANONICAL_VERSION_NUMBER\"/g" pims/__version__.py
    - export SCRIPTS_REPO_FULL_URL=https://$SCRIPTS_REPO_ACCESS_TOKEN_NAME:$SCRIPTS_REPO_ACCESS_TOKEN_VALUE@$SCRIPTS_REPO_URL
    - docker build --build-arg SCRIPTS_REPO_TAG=latest --build-arg PLUGIN_CSV="scripts/plugin-list.csv" --secret id=scripts_repo_url,env=SCRIPTS_REPO_FULL_URL -t $DOCKER_IMAGE_NAME_TMP_BUILD -f docker/backend.dockerfile .

publish-docker-image:
  stage: publish
  image: docker:latest
  needs:
    - job: build-docker-image-for-publish
      artifacts: false  # artifact are in docker cache (is it a safe assumption in a multi-runner env ?)
    - job: build-python-package
      artifacts: true  # dotenv file for $CANONICAL_VERSION_NUMBER
    - job: run-pytest
      artifacts: false
  rules:
    - if: $PUBLISH_ARTIFACTS == "true"
  script:
    - |
      if [ $IS_OPEN_SOURCE_RELEASE_CANDIDATE = "true" ]; then
        export DOCKER_IMAGE_NAME=DOCKERHUB_PIMS_REPO
        export TARGET_CI_REGISTRY=$DOCKERHUB_URL
        export TARGET_CI_REGISTRY_USER=$DOCKERHUB_USER
        export TARGET_CI_REGISTRY_PASSWORD=$DOCKERHUB_PASSWORD
      else
        export DOCKER_IMAGE_NAME=$CI_REGISTRY_IMAGE
        export TARGET_CI_REGISTRY=$CI_REGISTRY
        export TARGET_CI_REGISTRY_USER=$CI_REGISTRY_USER
        export TARGET_CI_REGISTRY_PASSWORD=$CI_REGISTRY_PASSWORD
      fi
    - echo "Target > registry:$TARGET_CI_REGISTRY user:$TARGET_CI_REGISTRY_USER"
    - docker login -u $TARGET_CI_REGISTRY_USER -p $TARGET_CI_REGISTRY_PASSWORD $TARGET_CI_REGISTRY
    - export DOCKER_IMAGE_NAME_FULL=$DOCKER_IMAGE_NAME:$(echo $CANONICAL_VERSION_NUMBER | sed 's/[^a-zA-Z0-9._-]/-/g')
    - docker tag $DOCKER_IMAGE_NAME_TMP_BUILD $DOCKER_IMAGE_NAME_FULL
    - docker push $DOCKER_IMAGE_NAME_FULL
    - docker rmi $DOCKER_IMAGE_NAME_FULL  # clean up

publish-python-package:
  image: python:$PYTHON_VERSION-slim-bullseye
  stage: publish
  rules:
    - if: $PUBLISH_ARTIFACTS == "true"
  needs:
    - job: run-pytest
      artifacts: false
    - job: build-python-package
      artifacts: true
  script:
    - pip install twine
    - |
      if [ $IS_OPEN_SOURCE_RELEASE_CANDIDATE = "true" ]; then
        export TARGET_PYTHON_REPO=https://upload.pypi.org/legacy/
        export TWINE_USERNAME=$PYPI_USERNAME
        export TWINE_PASSWORD=$PYPI_PASSWORD
      else
        export TARGET_PYTHON_REPO=${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/pypi
        export TWINE_USERNAME=gitlab-ci-token
        export TWINE_PASSWORD=$CI_JOB_TOKEN
      fi
    - twine upload dist/pims-*.tar.gz --repository-url $TARGET_PYTHON_REPO

# cleaning temporary docker images
clean-docker-images:
  stage: clean
  image: docker:latest
  rules:
    - when: always
  needs:
    - job: publish-docker-image
      artifacts: false
      optional: true
    - job: run-pytest
      artifacts: false
  script:
    # '|| true' so that job proceeds even if an image does not exist
    - docker rmi $DOCKER_IMAGE_NAME_TMP_BUILD || true
    - docker rmi $DOCKER_IMAGE_NAME_FOR_TESTS || true